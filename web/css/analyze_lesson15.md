# Просили, разобрать алгоритмы, разбираю
#### Класс: *ru/javawebinar/basejava/storage/SqlStorage.java*
#### Метод: *getAllSorted*

## Читать не обязательно :)

## Мой вариант, [коммит](https://github.com/uglic2018/basejava/commit/dad9fff360ce720933f4f21442cff9963f50011a)

### Используемые структуры:
1. **final Map<String, Resume> mapped = new HashMap<>();** 

   Nрезюме, хранит только указатели

2. **List<String> uuids = new ArrayList<>();**
 
   Nрезюме, хранит только указатели, строки уже есть в куче;
 
3. **final List<Resume> resumes = new ArrayList<>();**
   Nрезюме, хранит только указатели
   
4. временный String для rs.getString("type"): - число контактов, одновременно не более количества ContactTypes.values()
5. временный String для rs.getString("type"): - число секций, одновременно не более количества SectionTypes.values()
6. временный String для rs.getString("uuid"): - число контактов, не более одного одновременно
7. временный String для rs.getString("resume_uuid"): число секций, одновременно не более количества SectionTypes.values()

### Запросы:
1. "SELECT * FROM Resume LEFT JOIN Contact ON Resume.uuid = Contact.resume_uuid ORDER BY full_name, uuid;"
2. "SELECT * FROM Section ORDER BY resume_uuid;"

### Алгоритмическая сложность (грубо):
1. (Nконтактов + 1) * (rs.getString("uuid") + rs.getString("type")) = O(Nконтактов) - получение резюме с контактами;
2. (Nрезюме) = O(Nрезюме) - копирование (указатель резюме + указатель uuid) в HashMap, легко убирается сменой типа возвращаемого значения при получении резюме с контактами;
3. (Nрезюме) = O(Nрезюме) - копирование (указатель uuid) в ArrayList;
4. (Nрезюме*log(Nрезюме)) - сортировка (указатель uuid) в ArrayList;
5. (Nсекций)*(mapped.get(uuid) + resume.getUuid() + rs.getString("type")) = O(Nсекций) - получение и добавление секций

Итого:
Пункт 2, 3 и 4 выполняются целиком в памяти треда; пункты 1 и 5 - с обращением к серверу.
Технически скорость работы алгоритма максимум из { O(NxLogN -/- N^2) от числа резюме, O(N) от числа контактов или секций},
практически число секций и данных в них может оказаться более важным фактором, чем число резюме.
В худшем случае O(N^2 числа резюме) при малом числе контактов/секций, из-за сортировки.


## Учебный вариант lesson#14, [коммит](https://github.com/JavaWebinar/basejava/blob/02aee9744d7512dfa9ffbebe00ad415ffe5f71ea)

#### с аппроксимацией решения на разбивку на три запроса: резюме, добавление контактов, добавление секций

### Используемые структуры:
1. **Map<String, Resume> map = new LinkedHashMap<>();**

   Nрезюме, хранит только указатели.
   При это LinkedHashMap<>() состоит из [docs](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html):

   [1.1] new HashMap<String, Resume>(); - в моем варианте *mapped*

   [1.2] new LinkedList\<String\> или другой двухсторонний список; - в моем варианте *uuid*: ArrayList\<String\>

2. return **new ArrayList<>(map.values());**
 
   Nрезюме, хранит только указатели; - в моем варианте *resumes*

3. Временный String rs.getString("resume_uuid"); - число (контактов + секций), одновременно не более одной

Итого: основные структуры данных фактически идентичны с моими. Есть экономия на пару временных переменных
типа String. Алгоритмы заполнения отличаются, но не катастрофически.
Но при этом памяти LinkedList потребляет больше чем ArrayList из за двухсторонних указателей (+два указателя на резюме),
всего на (размер указателя) х 2 х (число резюме).

### Запросы: 
1. "SELECT * FROM Resume ORDER BY full_name, uuid;"
2. "SELECT * Contact;"
2. "SELECT * Section;"

### Алгоритмическая сложность (грубо):
1. (Nрезюме) * (rs.getString("uuid") + map.put(uuid, resume)) = O(Nрезюме) - загрузка резюме из БД
2. (Nконтактов) * (rs.getString("resume_uuid") + map.get(uuid)) = O(Nконтактов) - загрузка контактов
3. (Nсекций) * (rs.getString("resume_uuid") + map.get(uuid)) = O(Nсекций) - загрузка секций
4. (Nрезюме) * ( map.values().iterator) = O(Nрезюме)- копирование ссылок на резюме в новый список
Итого:
Пункт 4 выполняется целиком в памяти треда; пункты 1-3 - с обращением к серверу.
Технически скорость работы алгоритма максимум из { O(N) от числа резюме, O(N) от числа контактов или секций}.
Копирование списка из LinkedHashMap в ArrayList осуществляется через ссылки на следующий
элемент, это соответствует копированию в моем варианте элемента ArrayList в HashMap,
но медленнее.  
В среднем случае оценка O(N) от числа резюме/секций/контактов.

## ИТОГИ
1. Структуры хранения практически одинаковые, требования по памяти одинаковые.
2. Число запросов в моем случае на один меньше, но при этом один запрос сложнее.
3. В моей реализации лишняя сортировка: список String значений uuid. Значения
в список берутся из HashMap.keySet(), поэтому заведомо не упорядочены и скорее
всего тут ваш алгоритм окажется быстрее.
4. Реализация из урока проще, симпатичней и более масштабируема на случай изменения структуры данных.
5. Не согласен с претензием в том, что моя структура данных избыточна по потреблению памяти.   